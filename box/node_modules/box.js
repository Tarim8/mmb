//
// Box
//
// Play audio triggered by RFID tags
//
// Copyright Tarim 2013,2014,2015
//
// Box is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Box is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with Box.  If not, see <http://www.gnu.org/licenses/>.

'use strict';
var os = require( 'os' );
var pa = require( 'path' );
var fs = require( 'fs-extra' );
var _ = require( 'underscore' );
var mc = require( 'mediacontrol' );
var log = mc.log;
var action = mc.action;
var Session = mc.Session;

if( process.argv.length < 3 ) {
    log( 'Usage: node box DB_DIR' );
    process.exit();
}

var dbDir = process.argv[2];
// var dbDir = fs.realpathSync( process.argv[2] );
var platformDir = pa.join( dbDir, 'platform' );
var commands = new mc.Bed( pa.join( dbDir, 'commands' ) );
var universal = new mc.Bed( pa.join( dbDir, 'universal' ) );

var selectionPath = pa.join( dbDir, 'selection' );
var selection = {};
fs.readdirSync( selectionPath ).forEach( function( dir ) {
    selection[dir] = (new mc.Bed( pa.join( selectionPath, dir ) )).flowers;
} );

var collectionPath = pa.join( dbDir, 'collection' );
var collection = new mc.Bed( collectionPath );

var channel = new mc.Channel();
mc.media.channel = channel;

_.templateSettings.interpolate = /\{\{(.+?)\}\}/g;

var Tag = '';
var LastTime = 0;

var recordSession;
var recordTimeout;
function recordStop( signal ) {
    if( recordSession && !recordTimeout ) {
	recordSession.killSession( signal );
	recordTimeout = setTimeout( function() {
	    recordSession.killSession( signal );
	    recordSession.killSession( 'SIGKILL' );
	    recordSession = false;
	    recordTimeout = false;
	}, 700 );
    }
};
recordStop();

function recordNormalise( filePrefix ) {
    log( 'Info normalise ' + filePrefix + 'normal.wav' );
    new Session(
	'sox',
	[
	    filePrefix + 'record.wav',
	    filePrefix + 'normal.wav',
	    'gain', '-n', '-0.1'
	],
	function() {
	    log( 'Info normalised ' + this.exitCode );

	    collection.createFlower( filePrefix + 'normal.wav', {
		destName: '%D.wav',
		move: true,
		success: function() { lookupMemory( 'recordfinished.tag' ); },
		failure: function() { lookupMemory( 'recordfailed.tag' ); }
	    } );

	    try {
		fs.unlinkSync( filePrefix + 'record.wav' );
            } catch( err ) {
        	if( err.code !== 'ENOENT' ) throw( err );
            }
	},
	{ detached: false }
    );
};


action.record = function( path, options ) {
    if( options.action === 'stoprecord' ) {
	log( 'Info record stop' );
	if( recordSession ) {
	    recordStop( 'SIGINT' );
	} else {
	    return;
	}

    } else if( options.action === 'record' ) {
        if( recordSession ) {
            log( 'Warning record session in use' );
	    recordStop( 'SIGKILL' );
	    lookupMemory( 'recordbusy.tag' );
	    return;
        }

	var recordOptions = { detached: false, env: {} };
	if( options.audiodev ) { recordOptions.env.AUDIODEV = options.audiodev; }
	if( options.audiodriver ) { recordOptions.env.AUDIODRIVER = options.audiodriver; }

	var filePrefix=_.uniqueId( '/tmp/mc' + process.pid + '-' );

	log( 'Info recording ' + filePrefix + 'record.wav' );
	recordSession = new Session( 'rec', [ '-q', filePrefix + 'record.wav' ],
	    function() {
		log( 'Info recorded ' + this.exitCode );

		if( this.exitCode === 0 ) {
		    recordNormalise( filePrefix );

		} else {
		    try {
		        fs.unlinkSync( filePrefix + 'record.wav' );
		    } catch( err ) {
       			if( err.code !== 'ENOENT' ) throw( err );
		    }
		}
	    },
	    recordOptions
	);
    }
};

function mod( x, m ) {
    if( m === 0 ) return 0;
    x %= m;
    if( x < 0 ) x += m;
    return x;
};

var encoder = {};

action.enc = function( path, options ) {
    var forward;
    var value;

         if( Tag === "enca0.tag" ) { forward = true; value = 0; }
    else if( Tag === "enca1.tag" ) { forward = true; value = 1; }
    else if( Tag === "encb0.tag" ) { forward = false; value = 0; }
    else if( Tag === "encb1.tag" ) { forward = false; value = 1; }
    else { log( "Unknown encoder tag " + Tag ); return; }

    if( value === encoder[!forward] ) {
        log( 'Info playing ' + Tag );
        action.play( "", { move: forward ? 1 : -1 } );
    }

    encoder[forward] = value;
};

action.play = function( path, options ) {
    var move = parseInt( options.move );
    if( options.move === 'play' ) {
	move = channel.playing || LastTime + 3000 > Date.now() ? 1 : 0;
    } else if( move === NaN ) {
	move = 0;
    }

    collection.currentFlower = mod( collection.currentFlower + move, collection.flowers.length );
    log( 'Info playing ' + collection.currentFlower + ', ' + move );
    commands.synthesize( collection.flowers[collection.currentFlower] );
};

action.attachtag = function( path, options ) {
    log( 'Info attach ' + Tag );
    var flower = collection.flowers[collection.currentFlower];
    if( flower ) {
        if( collection.lookup( Tag ) ) {
            lookupMenu( 'tagexists.tag' );

        } else {
            fs.closeSync( fs.openSync( pa.join( flower.stalk, Tag ), 'a' ) );
            commands.synthesize( collection.flowers[collection.currentFlower] );
            collection = new mc.Bed( collectionPath );
        }

    } else {
        lookupMenu( 'unknown.tag' );
    }
};

action.detachtag = function( path, options ) {
	if( collection.lookup( Tag ) ) {
	    log( 'Info detach ' + Tag );
	    fs.unlinkSync( pa.join( collection.flowers[collection.currentFlower].stalk, Tag ) );
	    lookupMenu( 'tagdetached.tag' );
	    collection = new mc.Bed( collectionPath );

	} else {
	    lookupMenu( 'unknown.tag' );
	}
};

var fsAddFilesMaxDepth = 23;
var fsAddFiles = function( dir, depth ) {
    if( (depth||0) < fsAddFilesMaxDepth ) {
	fs.readdirSync( dir ).forEach( function( file ) {
	    var fullPath = pa.join( dir, file );
	    var stat;
	    try {
		stat = fs.statSync( fullPath );
	    } catch( err ) {
		if( err.code !== 'ENOENT' ) throw( err );
		stat = false;
	    }

	    if( stat && file[0] !== '.' ) {
		if( stat.isDirectory() ) {
		    fsAddFiles( fullPath, depth+1 );

		} else if( stat.isFile() ) {
		    if( pa.extname( file ) === '.wav' || pa.extname( file ) === '.mp3' ) {
			if( collection.lookup( file ) ) {
			    log( 'Copy file exists: ' + fullPath );

			} else {
			    log( 'Copy file ok: ' + fullPath );
			    collection.createFlower( fullPath );
			}
                    }
		}
	    }
	} );
    }
};

function testDir( dir ) {
    try {
        return fs.statSync( dir ).isDirectory();
    } catch( err ) {
        if( err.code !== 'ENOENT' ) throw( err );
        return false;
    }
};

function copyFiles( path ) {
    log( 'Info copying' );

    if( testDir( path) ) {
        fsAddFiles( path, 0 );
        log( 'Info copied' );
        return true;
    }

    return false;
};

function backupFiles( path ) {
    log( 'Info backup' );

    if( testDir( path ) ) {
        var destLog = pa.join( path, 'box.log' );
        try {
            fs.unlinkSync( destLog );
        } catch( err ) {
            if( err.code !== 'ENOENT' ) throw( err );
        }

        fs.copySync( pa.join( platformDir, 'box.log' ), destLog );
    
        fs.readdirSync( collectionPath ).forEach( function( dir ) {
            var destDir = pa.join( path, dir );
            try {
                fs.mkdirSync( destDir );
            } catch( err ) {
                if( err.code !== 'EEXIST' ) throw( err );
            }

            var srcDir = pa.join( collectionPath, dir );
            fs.readdirSync( srcDir ).forEach( function( file ) {
                try {
                    fs.copySync( pa.join( srcDir, file ), pa.join( destDir, file ) );
                } catch( err ) {
                    if( err.code !== 'EEXIST' ) throw( err );
                }

            } );
        } );

        log( 'Info backedup' );
        return true;
    }

    return false;
};

action.usbmount = function( path, options ) {
    log( 'Info usbmount' );
    var copied = false;
    var backedup = false;

    var mountDir = options.mountDir;
    if( testDir( mountDir ) ) {
        lookupMenu( 'usbmountmsg.tag' );

        var copyDir = options.copyDir;
        copied = copyDir && copyFiles( pa.join( mountDir, copyDir ) );

        var backupDir = options.backupDir;
        backedup = backupDir && backupFiles( pa.join( mountDir, backupDir ) );
    }

    lookupMenu(
        (copied && backedup) ? 'usbcopiedbackedupmsg.tag' :
        copied ? 'usbcopiedmsg.tag' :
        backedup ? 'usbbackedupmsg.tag' :
        'usbemptymsg.tag'
    );

    new Session( 'sudo', [ 'umount', mountDir ] );
};

var currentMenu = new mc.Bed();
currentMenu.flowers = selection.start;

function lookupMenu( tag ) {
    return commands.synthesize( currentMenu.lookup( tag ) ) ||
	   commands.synthesize( universal.lookup( tag ) );
};

function lookupMemory( tag ) {
    commands.synthesize( universal.lookup( 'busy.tag' ) );

    lookupMenu( tag ) ||
    commands.synthesize( collection.lookup( tag ) ) ||
    lookupMenu( 'unknown.tag' ) ||
    log( 'Tag unknown ' + tag );

    if( mc.marks.select ) {
	currentMenu = new mc.Bed();
	mc.marks.select.forEach( function( name ) {
	    if( selection[name] ) {
		selection[name].forEach( function( flower ) {
		    currentMenu.flowers.push( flower );
		} );

	    } else {
		log( 'Warn no selection ' + name );
	    }
	} );
	delete mc.marks.select;
    }

    commands.synthesize( universal.lookup( 'ready.tag' ) );
    LastTime = Date.now();
};

function lookupTag( line ) {
    Tag = line.
	  toString().
	  replace( /[^0-9a-z_\. ]/gi, '' ) +
	  '.tag';
    log( 'Tag lookup ' + Tag );

    lookupMemory( Tag );
};

var reader = new mc.Reader( process.stdin, lookupTag );
process.stdin.resume();

process.on( 'SIGINT', function() {
    log( 'Process sigint' );
    //recordStop( 'SIGKILL' );
    mc.action.exit();
} );

log(
    'Process start ' +
    fs.readFileSync( pa.join( dbDir, 'VERSION' ) ).toString().replace( /\n/g, ' ' ) +
    os.hostname() + ' ' +
    dbDir
);

new Session( 'git', ['log', '--pretty=format:%h %s', '--max-count=1'], null, {
    stdout: function( line ) {
         log( 'Git ' + line );
    },
    stderr: _.identity
} );

setTimeout( function() {
    lookupMemory( 'start.tag' );
}, 500 );


