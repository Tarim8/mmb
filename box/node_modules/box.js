//
// Box
//
// Play audio triggered by RFID tags
//
// Copyright Tarim 2013,2014,2015
//
// Box is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Box is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with Box.  If not, see <http://www.gnu.org/licenses/>.

'use strict';
var os = require( 'os' );
var pa = require( 'path' );
var fs = require( 'fs' );
var _ = require( 'underscore' );
var mc = require( 'mediacontrol' );
var log = mc.log;
var action = mc.action;
var Session = mc.Session;

if( process.argv.length < 3 ) {
    log( 'Usage: node box DB_DIR INPUT_STREAM' );
    process.exit();
}

var dbDir = process.argv[2];
// var dbDir = fs.realpathSync( process.argv[2] );
var platformDir = pa.join( dbDir, 'platform-box' );
var inputDevice = process.argv[3] || pa.join( platformDir, 'rfid' );
var commands = new mc.Bed( pa.join( dbDir, 'commands' ) );
var memories = new mc.Bed( pa.join( dbDir, 'memories' ) );
var universal = new mc.Bed( pa.join( dbDir, 'universal' ) );

var menusPath = pa.join( dbDir, 'menus' );
var menus = {};
fs.readdirSync( menusPath ).forEach( function( dir ) {
    menus[dir] = (new mc.Bed( pa.join( menusPath, dir ) )).flowers;
} );

var channel = new mc.Channel();
mc.media.channel = channel;

var Tag = '';
var LastTime = 0;

var recordDir = '/tmp/'
var recordName = 'box-recording.wav';
var recordFile = '';
var associate = false;

_.templateSettings.interpolate = /\{\{(.+?)\}\}/g;

var recordSession;
function recordStop() {
    if( recordSession ) {
	recordSession.killSession( 'SIGKILL' );
	recordSession = false;

	memories.fsAdd( recordDir );
	memories.findStalkIndex( recordDir );
    }
};

action.record = function( path, options ) {
    recordStop();
    if( options.onAir ) {
	// make directory with sound file
	recordDir = pa.join( dbDir, 'memories', Date.now().toString() );
	fs.mkdirSync( recordDir );
	recordFile = pa.join( recordDir, recordName );

	log( 'Info record ' + recordFile );
        recordSession = new Session(
	    'sox', [
		'-q',
		'-t', 'alsa',
		'-d',
		recordFile
            ], null,
	    options.audiodev ?
		{ 'env': {'AUDIODEV': options.audiodev} } :
		{}
	);
    }
};

function mod( x, m ) {
    if( m === 0 ) return 0;
    x %= m;
    if( x < 0 ) x += m;
    return x;
};
 
action.play = function( path, options ) {
    var move = parseInt( options.move );
    if( options.move === 'play' ) {
	move = channel.playing || LastTime + 10000 > Date.now() ? 1 : 0;
    } else if( move === NaN ) {
	move = 0;
    }

    memories.currentFlower = mod( memories.currentFlower + move, memories.flowers.length );
    log( 'Info playing ' + memories.currentFlower + ', ' + move );
    commands.synthesize( memories.flowers[memories.currentFlower] );
};

action.edittag = function( path, options ) {
    if( options.action === 'attach' ) {
	if( memories.lookup( Tag ) ) {
	    commands.synthesize( universal.lookup( 'tagattached.tag' ) );

	} else {
	    log( 'Info attach ' + Tag );
	    commands.synthesize( memories.flowers[memories.currentFlower] );
	    fs.closeSync( fs.openSync( pa.join( memories.flowers[memories.currentFlower].stalk, Tag ), 'a' ) );
	    memories = new mc.Bed( pa.join( dbDir, 'memories' ) );
	}

    } else if( options.action === 'detach' ) {
	if( memories.lookup( Tag ) ) {
	    log( 'Info detach ' + Tag );
	    fs.unlink( pa.join( memories.flowers[memories.currentFlower].stalk, Tag ) );
	    memories = new mc.Bed( pa.join( dbDir, 'memories' ) );

	} else {
	    commands.synthesize( universal.lookup( 'unknown.tag' ) );
	}

    } else {
	log( 'Warn unknown action ' + options.action );
    }
};

var currentMenu = new mc.Bed();
currentMenu.flowers = menus.play;

function lookupMenu( tag ) {
    return commands.synthesize( currentMenu.lookup( tag ) ) ||
	   commands.synthesize( universal.lookup( tag ) );
};

function lookupMemory( tag ) {
    commands.synthesize( universal.lookup( 'busy.tag' ) );

    lookupMenu( tag ) ||
    lookupMenu( 'any.tag' ) ||
    commands.synthesize( memories.lookup( tag ) ) ||
    lookupMenu( 'unknown.tag' ) ||
    log( 'Tag unknown ' + tag );

    if( mc.marks.menu ) {
	currentMenu = new mc.Bed();
	mc.marks.menu.forEach( function( name ) {
	    if( menus[name] ) {
		menus[name].forEach( function( flower ) {
		    currentMenu.flowers.push( flower );
		} );

	    } else {
		log( 'Warn no menu ' + name );
	    }
	} );
	delete mc.marks.menu;
    }

    commands.synthesize( universal.lookup( 'ready.tag' ) );
    LastTime = Date.now();
};

function lookupTag( line ) {
    line = line.
	toString().
	replace( /[^0-9a-z ]/gi, '' )
    log( 'Tag lookup ' + line );

    var pollv = line.split( ' ' );
    if( (pollv[2] || 'rfid') === 'rfid' ) pollv[2] = '';
    Tag = pollv[2] + pollv[0] + '.tag';
    lookupMemory( Tag );
};

var rfidReader = new mc.Reader( process.stdin, lookupTag );
process.stdin.resume();

process.on( 'SIGINT', function() {
    log( 'Process sigint' );
    mc.action.exit();
} );

log(
    'Process start ' +
    fs.readFileSync( pa.join( dbDir, 'VERSION' ) ).toString().replace( /\n/g, ' ' ) +
    os.hostname() + ' ' +
    dbDir + ' ' +
    inputDevice 
);

lookupMemory( 'start.tag' );

