//
// Media Control
//
// All manner of Media Control
//
// Copyright Tarim 2013,2014
//
// Media Control is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Media Control is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with Media Control.  If not, see <http://www.gnu.org/licenses/>.

'use strict';
var _ = require( 'underscore' );
var fs = require( 'fs-extra' );
var pa = require( 'path' );
var pr = require( 'properties' );

//
// Error
//
function log( message ) {
    var now = new Date().toISOString().replace( /[TZ]/g, ' ' );
    console.log(
	now + message.toString().trim().replace( /\n+ */g, '\n' + now )
    );
};

function copyAttributes( src, dest ) {
    for( var key in src ) {
	if( src.hasOwnProperty( key ) ) {
    	    dest[key] = src[key];
	}
    }
};

function toNumber( str ) {
    return parseFloat( str.replace( /.*\//, '' ) );
};

//
// Create a session (process with a new group session leader)
//
// Session.leader                  lead process
// Session.pgid                    session process group id
// Session.prototype.spawn()       library to spawn process
// Session.prototype.killSession() kill everything in process session group
//
function Session( command, args, callback, options ) {
    options = options || { detached: true };
    this.leader = this.spawn( command, args || [], options );

    if( this.leader ) {
	if( callback ) this.leader.on( 'close', callback );

	this.leader.stdout.on( 'data', options.stdout || log );
	this.leader.stderr.on( 'data', options.stderr || log );
	this.leader.stdin.on( 'error', options.stdin || log );

	if( options.detached ) {
	    this.pgid = this.leader.pid;
	}

    } else {
	log( 'Process noexec ' + command + ' ' + args );
    }
};

Session.prototype.spawn = require( 'child_process' ).spawn;
Session.prototype.killSession = function( signal ) {
	try {
	    if( this.pgid ) {
		process.kill( -(this.pgid), signal );
		// this.pgid = false;
	    }
	    if( this.leader.pid ) {
		process.kill( this.leader.pid, signal );
	    }
	} catch( err ) {
	    if( err.code !== 'ESRCH' ) throw( err );
	}
};

Session.prototype.write = function( data ) {
    this.leader.stdin.write( data + '\n' );
};


//
// Flower class
//
// Flower.petals		[ 'play.tag', 'one.mp3', 'amp.on.out' ]
// Flower.stalk			'/dir/bbb/'

function Flower( petals, stalk ) {
    this.petals = petals;
    if( stalk ) this.stalk = stalk;
};
Flower.prototype.stalk = '';

//
// Flower.lookup: Return the flower if petal exists
//
Flower.prototype.lookup = function( petal ) {
    return this.petals.indexOf( petal ) != -1 && this;
};

// For each petal, look up its tag in commands
// and execute all functions in the corresponding command flower
Flower.prototype.synth = function( commands ) {
    var flower = this;
    flower.petals.forEach( function( petal ) {
	if( _.isFunction( petal ) ) {
	    petal( flower.stalk );

	} else {
	    // for a.b.c.thing lookup b.c.type - should try c.type too
	    var commandFlower = commands.lookup( petal.replace( /[^\.]*\./, '' ) + '.type' );	// .*/?
	    if( commandFlower ) {
		commandFlower.petals.forEach( function( commandPetal ) {
		    if( _.isFunction( commandPetal ) ) {
			commandPetal( pa.join( flower.stalk, petal ) );
		    }
		} );
	    }
	}
    } );
    return true;
};



//
// Bed class
//
// A collection of flowers
// Bed.flowers		array of flowers
// Bed.currentFlower	index of current flower
// Bed.earth		main directory
//

function Bed( buds, stalk ) {
    this.flowers = [];

    if( _.isArray( buds ) ) {
	this.earth = stalk;
	this.add( buds, stalk );

    } else if( _.isString( buds ) ) {
	this.earth = buds;
	this.fsAdd( buds );
    }
};

Bed.prototype.currentFlower = 0;

Bed.prototype.add = function( buds, stalk ) {
    var flowers = this.flowers;
    buds.forEach( function( bud ) {
	flowers.push( new Flower( bud, stalk ) );
    } );
};

Bed.prototype.maxDepth = 50;
Bed.prototype.fsAdd = function( dir, depth ) {
    if( (depth||0) < this.maxDepth ) {
	var me = this;
	var files = [];
	fs.readdirSync( dir ).forEach( function( file ) {
	    var fullPath = pa.join( dir, file );
	    var stat;
	    try {
		stat = fs.statSync( fullPath );
	    } catch( err ) {
		if( err.code !== 'ENOENT' ) throw( err );
		stat = false;
	    }

	    if( stat ) {
		if( stat.isDirectory() ) {
		    me.fsAdd( fullPath, depth+1 );

		} else if( pa.extname( file ) === '.action' ) {
		    var mediaType = pa.extname( 'x.' + pa.basename( file, '.action' ) ).slice(1);
		    var content = pr.parse( fs.readFileSync( fullPath ).toString() );
		    files.push( function( path ) {
			action[mediaType]( path, content );
		    } );

		} else {
		    files.push( file );
		}
	    }
	} );

	if( files.length ) {
	    me.flowers.push( new Flower( files, dir ) );
	}
    }
};

Bed.prototype.findStalkIndex = function ( stalk ) {
    for( var flower in this.flowers ) {
	if( this.flowers[flower].stalk === stalk ) {
	    this.currentFlower = parseInt( flower );
	    return flower;
	}
    }
};

Bed.prototype.lookup = function( petal ) {
    for( var flower in this.flowers ) {
	if( this.flowers[flower].lookup( petal ) ) {
	    this.currentFlower = parseInt( flower );
	    return this.flowers[flower];
	}
    }
};

Bed.prototype.lookSynth = function( commands, tag ) {
    var flower = this.lookup( tag );
    if( flower ) flower.synth( commands );
    return flower;
};

Bed.prototype.synthesize = function( flower ) {
    return flower && flower.synth( this );
};

Bed.prototype.createFlower = function( src, options ) {
    var me = this;
    options = options || {};
    var now = Date.now();

    var dirName;
    var dirBase;
    for( var j = now; j < now + 50; ++j ) {
	try {
	    dirBase = j.toString();
	    dirName = pa.join( me.earth, dirBase );
	    fs.mkdirSync( dirName );
	} catch( err ) {
	    if( err.code !== 'EEXIST' ) throw( err );
	    continue;
	}
	break;
    }

    var destName = options.destName ? options.destName.replace( /%D/, dirBase ) : pa.basename( src );
    (options.move ? fs.move : fs.copy)( src, pa.join( dirName, destName ), function( err ) {
	if( err ) {
	    options.failure && options.failure( err );
	} else {
	    me.fsAdd( dirName );
	    me.findStalkIndex( dirName );
	    options.success && options.success();
	}
    } );

    return;
};


//
// Channel class	video/audio/timer channel
//
// Channel.media	media and player object
//
function Channel() {};

Channel.prototype.media = {};		// media player and object
Channel.prototype.id = 0;		// used to check if callback is current
Channel.prototype.fullIntensity = 100;
Channel.prototype.frameTime = 40;	// frame time for fades



//
// play( media )	play the media object
//
Channel.prototype.play = function( media ) {
    this.setBrightness( this.fullIntensity );
    this.next = false;

    if( media.name != this.media.name || !this.playing ) {
	var me = this;
	log( 'Channel play ' + media.name );
	if( me.playing && (media.fadeLast || me.media.fadeMe) ) {
	    var nextFunc = function() {
		me.stop();
		me.play( media );
	    };

	    me.next = nextFunc;
	    me.startFade( Math.max(media.fadeLast || 0, me.media.fadeMe || 0 ), nextFunc );

	} else {
	    me.stop();
	    me.media = media;

	    var id = me.id;
	    me.media.start( function() {
		if( id == me.id ) {
		    me.stop();
		    if( me.media.loop ) {
			me.play( me.media );

		    } else if( me.next ) {
			me.next();
		    } else if( me.mediaFinish ) {
			me.mediaFinish();
		    }
		}
	    } );
	    me.playing = true;
	    me.setVolume( me.fullIntensity );
	}
    }
};

//
// stop the media object
//
Channel.prototype.stop = function() {
    this.stopFade();
    if( this.media && this.media.stop ) this.media.stop();
    this.playing = false;
    this.id = ( this.id + 1 ) % 32768;
}

Channel.prototype.setBrightness = function( intensity ) {
    this.intensity = Math.floor( intensity );
    if( this.intensity < 0 ) this.intensity = 0;
    this.media.setBrightness && this.media.setBrightness( this.intensity );
};

Channel.prototype.setVolume = function( intensity ) {
    this.intensity = Math.floor( intensity );
    if( this.intensity < 0 ) this.intensity = 0;
    this.media.setVolume && this.media.setVolume( this.intensity );
};

Channel.prototype.startFade = function( time, callback ) {
    var me = this;
    me.stopFade();

    me.fadeBy = Date.now() + time;
    me.fader = setInterval( function() {
	var fadeTime = me.fadeBy - Date.now();
	var intensity = me.intensity * (fadeTime - me.frameTime) / fadeTime;
	me.setBrightness( intensity );
	me.setVolume( intensity );

	if( intensity <= 0 ) {
	    me.stopFade();
	    callback();
	}
    }, me.frameTime );
};

Channel.prototype.stopFade = function() {
    clearInterval( this.fader );
    this.fader = false;
    this.fadeBy = 0;
};




//
// parse options in action file
//
function parseOptions( type, literal, path ) {
    if( type == "path" ) {
	return path;
    } else if( _.isNumber( type ) ) {
	return pa.basename( path ).split( '.' )[ type ];
    } else if( type == "rnd" ) {
	return literal[Math.floor( Math.random() * literal.length )];
    } else {
	return literal;
    }
};

//
// marks object to keep control of marked values
//
var marks = {};


//
// action commands can be called from the fs database
//
var action = {

//
// media: independent control of media players
// options:
//   stop
//
media: function( path, options ) {
    if( options.stop ) {
	log( 'Channel stop' );
	media.channel.stop();
    } // else try options.volume
},

//
// out: write a value to a file
// options:
//   outputType = constant | rnd  | path | POSITION
//     constant, random letter, path, position in filename
//   output=VALUE
//     constant, or string for rnd
//
out: function( path, options ) {
    var value = parseOptions( options.outputType, options.output, path );
    fs.appendFileSync( path, value + '\n' );
},


//
// set: set an internal value
// options:
//   type = set | append | clear
//     set a variable, append to an array, clear a variable or array
//   nameType = constant | rnd  | path | POSITION
//     constant, random letter, path, position in filename
//   name = VALUE
//     constant, or string for rnd
//   valueType = constant | rnd  | path | POSITION
//     constant, random letter, path, position in filename
//   value = VALUE
//     constant, or string for rnd
//
set: function( path, options ) {
    var name = parseOptions( options.nameType, options.name, path );
    var value = parseOptions( options.valueType, options.value, path );

    if( options.type == "append" ) {
	if( _.isUndefined( marks[name] ) ) {
	    marks[name] = [];
	}
	marks[name].push( value );

    } else if( options.type == "clear" ) {
	delete marks[name];

    } else {
	marks[name] = value;
    }
},


//
// exit the mediacontrol system
//
exit: function( path, options ) {
    log( 'Process stop' );
    media.channel.stop();
    // if( mplayer.session ) mplayer.session.killSession();
    // process.exit();
    process.kill( process.pid );
},


//
// shutdown the computer
// options:
//   reboot: 1 | 0
//     reboot or power off
//   when: TIME
//     delay before shutdown
//
shutdown: function( path, options ) {
    var shutdownType = options.reboot ? '-r' : '-P';
    var shutdownDelay = '+' + (_.isNumber( options.when ) ? options.when : '0');
    log( 'Process shutdown ' + shutdownType + ' ' + shutdownDelay );
    new Session( 'sudo', ['-n', 'shutdown', '-h', shutdownType, shutdownDelay] );
},
};


//
// media constructor generator
//
var media = {
create: function( type, startFunc, stopFunc ) {
    media[type] = function( name, options ) {
	this.name = name;
	copyAttributes( options, this );
    };

    action[type] = function( path, options ) {
	media.channel.play( new media[type]( path, options ) );
    };	

    media[type].prototype.start = startFunc;

    if( stopFunc ) {
	media[type].prototype.stop = stopFunc;

    } else {
	media[type].prototype.stop = function() {
	    this.session && this.session.killSession();
	    this.session = false;
	};
    }
},

channel: null
};

//
// timer class
//
media.create(
    'timer',

    function( callback ) {
	this.timer = setTimeout( callback, toNumber( this.name ) );
    },

    function() {
	this.timer && clearTimeout( this.timer );
	this.timer = false;
    }
);



//
// audio sox class
//
media.create(
    'sox', 

    function( callback ) {
	this.session = new Session(
	    'play', _.flatten( [
	        '-q', this.name,
		this.channel == 'right' ? ['remix', '0', '-'] :
		this.channel == 'left' ? ['remix', '-', '0'] :
		this.channel == 'unsync' ? ['remix', '-i', '-'] :
		[]
	    ] ), callback
	);
    },

    function() {
	this.session && this.session.killSession( 'SIGKILL' );
	this.session = false;
    }
);

media.sox.prototype.setVolume = function( volume ) {
    new Session( 'amixer', [ 'set', '-q', 'Master', (volume*255/100) + '' ], null, {} );
};

media.create(
    'soxstat', 

    function( callback ) {
	this.session = new Session(
	    'play', _.flatten( [
	        '-q', this.name,
		this.channel == 'right' ? ['remix', '0', '-'] :
		this.channel == 'left' ? ['remix', '-', '0'] :
		this.channel == 'unsync' ? ['remix', '-i', '-'] :
		[],
		'stat', '-v'
	    ] ), callback,
	    {
	        detached: true,
	        stderr: function( data ) {
		    log( 'sox ' + data );
		    data.toString().search( /^(Samples read: *)?[0-9\.]+[\r\n]*$/ ) == 0 &&
			callback && callback();
	        }
	    }
	);
    },

    media.sox.prototype.stop
);

media.soxstat.prototype.setVolume = media.sox.prototype.setVolume;



media.create(
    'festival',

    function( callback ) {
	this.session = new Session( 'festival', [ '-b', '--tts', this.name ], callback );
    }
);

media.festival.prototype.setVolume = media.sox.prototype.setVolume;



//
// frame buffer still display class
//
media.create(
    'fbi',

    function( callback ) {
	this.session = new Session( 'sh', ['-c', 'fbi /dev/fb0 --noverbose ' + this.name + '< /dev/tty6'], callback );
    }
);

//
// omxplayer video class
//
media.create(
    'omxplayer',

    function( callback ) {
	this.session = new Session( 'omxplayer', [
	    '--vol', (this.maxvolume || 0).toString(),
	    '--adev', (this.audio || 'both'), 
	    this.name
	], callback );
    }
);

//
// mplayer video class
//
var mplayer = {};
media.create(
    'mplayer',

    function( callback ) {
	if( !mplayer.session ) {
	    mplayer.session = new Session( 'mplayer', [
		this.name,
		'-slave', '-idle',
		// '-quiet', '-nolirc', '-osdlevel', '0', '-noconsolecontrols',
		'-vo', 'fbdev2', '-fs',
		this.hold ? '-fixed-vo' : '-nofixed-vo',
		'-xy', '1024', '-zoom',
		'-brightness', '0', '-saturation', '0',
		'-loop', this.loop ? '0' : '1',
		'-ao', 'sdl',
		// '-softvol', '-softvol-max', (this.maxvolume || 100).toString(), 
		'-volume', (this.volume || 100).toString(),
		'-msglevel', 'global=6', '-really-quiet',
		// '-vf', 'eq2',
	    ], _.identity, {} );

	    new Reader( mplayer.session.leader.stdout, function( line ) {
		if( line.trim() === 'EOF code: 1' ) {
		    log( 'mplayer mediafinish' );
		    mplayer.callback && mplayer.callback();
		}
	    } );

	} else {
	    mplayer.session.write( 'loadfile "' + this.name + '"' );
	    mplayer.session.write( 'loop ' + (this.loop ? '0' : '-1') + ' 1' );
	}

	this.session = mplayer.session;
	mplayer.callback = callback;

	// this.loop || this.session.write('seek 90 1');
    },

    // media.mplayer.protocol.stop()
    function() {
	this.session.write( 'stop' );
    }
);

media.mplayer.prototype.fadeLast = 0;
media.mplayer.prototype.fadeMe = 0;

media.mplayer.prototype.setBrightness = function( intensity ) {
    if( this.session ) {
	this.session.write( 'saturation ' + (intensity-100) + ' 1' );
	this.session.write( 'brightness ' + (intensity-100) + ' 1' );
    }
};

media.mplayer.prototype.setVolume = function( volume ) {
    if( this.session ) {
	this.session.write( 'volume ' + volume + ' 1' );
    }
};

//
// mplayer video class per process
//
media.create(
    'mplayersingle',

    function( callback ) {
	this.session = new Session( 'mplayer', [
	    this.name,
	    '-slave',
	    '-quiet', '-nolirc', '-osdlevel', '0', '-noconsolecontrols',
	    '-vo', 'fbdev2', '-fs',
	    this.hold ? '-fixed-vo' : '-nofixed-vo',
	    '-xy', '1024', '-zoom',
	    '-loop', this.loop ? '0' : '1',
	    '-ao', 'sdl',
	    '-softvol', '-softvol-max', (this.volume || 100).toString(),
	    '-brightness', '0', '-saturation', '0', '-volume', '100',
	    '-msglevel', 'global=6', '-really-quiet',
	    // '-vf', 'eq2',
	    ], callback
	);

	// this.session.write('seek 90 1');
    }
);

media.mplayersingle.prototype.fadeLast = 0;
media.mplayersingle.prototype.fadeMe = 0;
media.mplayersingle.prototype.setBrightness = media.mplayer.prototype.setBrightness;
media.mplayersingle.prototype.setVolume = media.mplayer.prototype.setVolume;



//
// mplayer still class
//
media.create(
    'mplayerstill',

    function( callback ) {
	this.session = new Session( 'mplayer', [
	    'mf://' + this.name,
	    '-idle',
	    '-slave',
	    '-quiet', '-nolirc', '-osdlevel', '0', '-noconsolecontrols',
	    '-vo', 'fbdev2', '-fs',
	    '-fixed-vo',
	    '-brightness', '0', '-saturation', '0', '-nosound',
	    '-really-quiet',
	    '-msglevel', 'cplayer=4',
	    // '-vf', 'eq2',
	    ], callback
	);
    }
);

//
// Stream Reader class
//
function Reader( file, callback ) {
    if( _.isString( file ) ) {
	this.stream = fs.createReadStream( file, { flags: 'r+' } );
    } else {
	this.stream = file;
    }

    this.rl = this.createInterface( {
	input: this.stream,
	output: null,
	terminal: false
    } );

    this.rl.on( 'line', callback );

    if( true || _.isString( file ) ) {
	this.rl.on( 'close', function() {
	    log( 'Reader close ' + file );
	} );

	this.rl.on( 'SIGINT', function() {
	    log( 'Reader sigint ' + file );
	} );
    }
};

Reader.prototype.createInterface = require( 'readline' ).createInterface;

exports.log = log;
exports.copyAttributes = copyAttributes;
exports.Session = Session;
exports.Flower = Flower;
exports.Bed = Bed;
exports.Channel = Channel;
exports.media = media;
exports.action = action;
exports.marks = marks;
exports.Reader = Reader;
